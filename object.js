// Напиши функцию, которая перебирает все ключи объекта и возвращает массив всех значений этого объекта.

// function myValues(obj) {
//     let result = [];

//     for (let key in obj) {
//         result.push(obj[key])
//     }

//     return result;
// }

// const obj = { a: 1, b: 2, c: 3 };
// console.log(myValues(obj));  // [1, 2, 3]

// ________________________________________________________________________________________________________________________________________________________________________________________________________________

// Напиши функцию, которая будет получать объект и возвращать массив его ключей, используя метод Object.keys.

// function myKeys(obj) {
//     let result = [];

//     for (let key in obj) {
//         result.push(key)
//     }

//     return result;
// }

// const obj = { a: 1, b: 2, c: 3 };
// console.log(myKeys(obj));  // ['a', 'b', 'c']

// ________________________________________________________________________________________________________________________________________________________________________________________________________________

// Напиши функцию, которая будет получать объект и возвращать массив его пар "ключ-значение" в виде подмассивов, используя метод Object.entries.

// function myEntries(obj) {
//     let result = [];

//     for (let key in obj) {
//         result.push([key, obj[key]])
//     }
//     return result
// }

// const obj = { a: 1, b: 2, c: 3 };
// console.log(myEntries(obj));  // [['a', 1], ['b', 2], ['c', 3]] 

// ________________________________________________________________________________________________________________________________________________________________________________________________________________

// Напиши функцию myAssign(target, ...sources), которая копирует все перечисляемые собственные свойства из одного или нескольких исходных объектов в целевой объект (target). 
// Она должна возвращать этот целевой объект.

// function myAssign(target, ...sources) {
//     for (let source of sources) {
//         for (let key in source) {
//             if (source.hasOwnProperty(key)) target[key] = source[key]
//         }
//     }

//     return target;
// }

// const obj1 = { a: 1, b: 2 };
// const obj2 = { b: 3, c: 4 };
// const obj3 = { d: 5 };

// const result = myAssign(obj1, obj2, obj3);

// console.log(result); // { a: 1, b: 3, c: 4, d: 5 }

// ________________________________________________________________________________________________________________________________________________________________________________________________________________

// Попробуй реализовать myFreeze. Вот как это может выглядеть:

// Мы будем использовать Object.defineProperty, чтобы изменить поведение каждого свойства объекта, запрещая его изменение.

// Мы должны убедиться, что мы обрабатываем все вложенные объекты, делая их тоже замороженными (глубокая заморозка).

// function myFreeze(obj) {
//     for (let key in obj) {
//         Object.defineProperty(obj, key, {
//             writable: false,
//             configurable: false,
//         })
//     }

//     return obj;
// }

// ________________________________________________________________________________________________________________________________________________________________________________________________________________

// Спочатку ми заморожуємо сам об'єкт через Object.freeze(obj)

// Потім перебираємо всі його ключі:

// Якщо значення ключа — це об'єкт (і не null), то викликаємо deepFreeze рекурсивно для цього значення

// Таким чином, ми «пірнаємо» вглиб структури і заморожуємо все

// function deepFreeze(obj) {
//     Object.freeze(obj)

//     for (let key in obj) {
//         if (typeof obj[key] === "object" && obj[key] !== null) {
//             deepFreeze(obj[key])
//         }
//     }

//     return obj
// }

// const person = {
//     name: 'Alex',
//     address: {
//         city: 'Kyiv',
//         geo: {
//             lat: 50.45,
//             lng: 30.52
//         }
//     }
// };

// deepFreeze(person);

// person.name = 'Bob'; // не зміниться
// person.address.city = 'Lviv'; // не зміниться
// person.address.geo.lat = 0; // не зміниться

// ________________________________________________________________________________________________________________________________________________________________________________________________________________

//  Створи функцію deepClone(obj), яка створює глибоку копію об'єкта. Це означає, що всі вкладені об'єкти теж мають бути скопійовані, а не просто передані за посиланням.

// function deepClone(obj) {
//     let copy = {}

//     for (let key in obj) {
//         if (typeof obj[key] === 'object' && obj[key] !== null) {
//             copy[key] = deepClone(obj[key])
//         } else {
//             copy[key] = obj[key];
//         }
//     }

//     return copy
// }

// ________________________________________________________________________________________________________________________________________________________________________________________________________________

// Реализуй функцию myMerge, которая будет объединять два объекта. При этом:

// Если ключи совпадают, то значения объектов должны объединяться (для этого просто сложи их).

// Если ключи разные — просто добавляй новый ключ в результирующий объект.

// Тебе нужно обрабатывать как примитивные типы, так и объекты (в случае объектов — рекурсивно).

function myMerge(obj1, obj2) {
    
}